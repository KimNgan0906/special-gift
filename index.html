<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√≥n qu√† ƒë·∫∑c bi·ªát</title>
    <!-- Th∆∞ vi·ªán Three.js ƒë·ªÉ v·∫Ω 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playpen+Sans:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* ---- General Styling ---- */
        body {
            margin: 0;
            font-family: 'Playpen Sans', cursive;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
        }

        /* ---- Page Switching Logic ---- */
        .page {
            display: none;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .page.active {
            display: flex;
        }
        
        /* ---- Password Page ---- */
        #password-page {
            background-color: #f0f0f0;
        }
        
        .container {
            text-align: center;
            background-color: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-family: 'Playpen Sans', cursive;
            color: rgb(0, 0, 0);
            font-size: 32px;
            margin-bottom: 30px;
            text-shadow: 0 4px 4px rgba(145, 145, 145, 0.7);
        }

        .password-wrapper {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .password-image {
            width: 150px;
            height: 150px;
            background-color: #f5f5f5;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed #ddd;
        }

        .password-image img {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            object-fit: cover;
            display: none; /* ·∫®n cho ƒë·∫øn khi load xong */
        }

        .password-image img.loaded {
            display: block;
        }

        .placeholder-text {
            color: #999;
            font-size: 14px;
            text-align: center;
        }

        .password-input-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #password-display {
            width: 100%;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 30px;
            letter-spacing: 10px;
            text-align: center;
            line-height: 40px;
            color: #333;
        }

        .keypad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .keypad button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background-color: #f9f9f9;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .keypad button:hover {
            background-color: #e0e0e0;
        }

        .keypad button:active {
            transform: scale(0.95);
        }

        #status-message {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            height: 20px;
        }

        /* ---- Birthday Page ---- */
        #birthday-page {
            position: relative;
        }
        
        #matrix-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .greeting-container {
            position: relative;
            z-index: 2;
            color: white;
            font-size: 8vw;
            font-weight: bold;
            text-shadow: 0 0 15px #fff, 0 0 25px #fff;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
            position: absolute;
        }

        .greeting-container.visible {
            opacity: 1;
        }
        
        .gift-container {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            visibility: hidden;
        }

        .gift-container.visible {
            opacity: 1;
            visibility: visible;
        }

        .gift-container img {
            width: 250px;
            height: 250px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.7);
        }

        .gift-container button {
            font-family: 'Playpen Sans', cursive;
            padding: 15px 30px;
            font-size: 20px;
            border: none;
            border-radius: 50px;
            background-color: #ff69b4;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 20px #ff69b4;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .gift-container button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px #ff69b4;
        }
        
        /* ---- Galaxy Page ---- */
        #galaxy-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #galaxy-canvas:active {
            cursor: grabbing;
        }

        .galaxy-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            backdrop-filter: blur(5px);
            max-width: 200px;
        }

        .control-item {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-icon {
            font-size: 16px;
            width: 20px;
        }

        /* Error message styling */
        .error-message {
            color: #ff6b6b;
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- ======================= PAGE 1: M·∫¨T KH·∫®U ======================= -->
    <div id="password-page" class="page active">
        <div class="container">
            <h1>NH·∫¨P PASS ƒêI NG∆Ø·ªúI ƒê·∫∏P</h1>
            <div class="password-wrapper">
                <div class="password-image">
                    <img id="girl-img-1" alt="·∫¢nh 1">
                    <div class="placeholder-text" id="img-placeholder-1">
                        ƒêang t·∫£i ·∫£nh...<br>
                        <small>ƒê·∫∑t file 1.png trong c√πng th∆∞ m·ª•c</small>
                    </div>
                </div>
                <div class="password-input-area">
                    <div id="password-display"></div>
                    <div class="keypad">
                        <button>1</button><button>2</button><button>3</button>
                        <button>4</button><button>5</button><button>6</button>
                        <button>7</button><button>8</button><button>9</button>
                        <button id="submit">‚úî</button><button>0</button><button id="delete">‚å´</button>
                    </div>
                    <div id="status-message"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ======================= PAGE 2: CH√öC M·ª™NG ======================= -->
    <div id="birthday-page" class="page">
        <canvas id="matrix-canvas"></canvas>
        <div id="greeting1" class="greeting-container">Ch√∫c m·ª´ng</div>
        <div id="greeting2" class="greeting-container">sinh nh·∫≠t</div>
        <div id="greeting3" class="greeting-container">b·∫°n y√™u</div>
        <div id="gift" class="gift-container">
            <img id="girl-img-2" alt="·∫¢nh 2">
            <button id="gift-button">Qu√† n√®</button>
        </div>
    </div>

    <!-- ======================= PAGE 3: V≈® TR·ª§ ======================= -->
    <div id="galaxy-page" class="page">
         <canvas id="galaxy-canvas"></canvas>
    </div>

    <!-- Audio element -->
    <audio id="galaxy-audio" src="traoem1.MP3" loop></audio>

    <script>
        // --- C·∫§U H√åNH ƒê∆Ø·ªúNG D·∫™N ·∫¢NH CHO T·ª™NG TRANG ---
        const imagePathsPage1 = [
            './login1.jpg', './img/1.png', 'img/1.png', '../1.png', 
            'https://picsum.photos/200/200?random=1'
        ];
        const imagePathsPage2 = [
            './chucmung.jpg', './img/2.png', 'img/2.png', '../2.png', 
            'https://picsum.photos/250/250?random=2'
        ];
        const imagePathsPage3 = [
            './galaxy.jpg', './img/3.png', 'img/3.png', '../3.png',
            'https://picsum.photos/200/200?random=3'
        ];

        // Bi·∫øn global ƒë·ªÉ l∆∞u texture cho trang v≈© tr·ª•
        let globalTexture = null;

        // H√†m t·∫£i ·∫£nh v·ªõi fallback (cho th·∫ª <img> c·ªßa HTML)
        function loadImageWithFallback(imgElement, placeholderElement, paths, imageName, index = 0) {
            if (index >= paths.length) {
                if (placeholderElement) {
                    placeholderElement.innerHTML = `
                        ‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh!<br>
                        <small style="color: #666;">
                            H√£y ƒë·∫∑t file "${imageName}" v√†o:<br>
                            - C√πng th∆∞ m·ª•c v·ªõi file HTML<br>
                            - Ho·∫∑c trong th∆∞ m·ª•c "img/"
                        </small>
                    `;
                }
                return;
            }

            const currentPath = paths[index];
            const testImg = new Image();
            
            testImg.onload = function() {
                imgElement.src = currentPath;
                imgElement.classList.add('loaded');
                if (placeholderElement) {
                    placeholderElement.style.display = 'none';
                }
                console.log(`‚úÖ ƒê√£ t·∫£i ·∫£nh ${imageName} t·ª´: ${currentPath}`);
            };
            
            testImg.onerror = function() {
                console.log(`‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh t·∫°i: ${currentPath}`);
                loadImageWithFallback(imgElement, placeholderElement, paths, imageName, index + 1);
            };
            
            testImg.src = currentPath;
        }

        // H√†m t·∫£i texture cho Galaxy (Trang 3) v·ªõi fallback
        function loadGalaxyTextureWithFallback(paths, index = 0) {
            if (index >= paths.length) {
                console.log('‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh cho Galaxy, t·∫°o texture thay th·∫ø.');
                createFallbackTexture();
                return;
            }
            const currentPath = paths[index];
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                currentPath,
                function(texture) { // OnLoad
                    globalTexture = texture;
                    console.log(`‚úÖ ƒê√£ t·∫£i texture cho Galaxy t·ª´: ${currentPath}`);
                },
                undefined, // onProgress
                function(err) { // onError
                    console.log(`‚ùå Kh√¥ng t·∫£i ƒë∆∞·ª£c texture t·ª´: ${currentPath}`);
                    loadGalaxyTextureWithFallback(paths, index + 1);
                }
            );
        }

        // T·∫°o texture thay th·∫ø khi kh√¥ng c√≥ ·∫£nh
        function createFallbackTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, '#ff69b4');
            gradient.addColorStop(0.5, '#9c27b0');
            gradient.addColorStop(1, '#673ab7');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üíñ', 32, 20);
            ctx.font = '8px Arial';
            ctx.fillText('BIRTHDAY', 32, 35);
            ctx.fillText('GIFT', 32, 45);
            
            globalTexture = new THREE.CanvasTexture(canvas);
            console.log('‚úÖ ƒê√£ t·∫°o fallback texture cho Galaxy');
        }

        // --- B·∫Øt ƒë·∫ßu t·∫£i c√°c ·∫£nh ---
        // T·∫£i ·∫£nh cho Trang 1
        const img1 = document.getElementById('girl-img-1');
        const placeholder1 = document.getElementById('img-placeholder-1');
        loadImageWithFallback(img1, placeholder1, imagePathsPage1, '1.png');

        // T·∫£i ·∫£nh cho Trang 2
        const img2 = document.getElementById('girl-img-2');
        loadImageWithFallback(img2, null, imagePathsPage2, '2.png');
        
        // T·∫£i texture cho Trang 3 (Galaxy)
        loadGalaxyTextureWithFallback(imagePathsPage3);


        // --- LOGIC CHUY·ªÇN TRANG ---
        let matrixInterval;
        let galaxyAnimationId;

        function switchPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');

            if (pageId === 'birthday-page') {
                initBirthdayPage();
            } else if (pageId === 'galaxy-page') {
                if (matrixInterval) clearInterval(matrixInterval);
                if (galaxyAnimationId) cancelAnimationFrame(galaxyAnimationId);
                initGalaxyPage();
            }
        }

        // --- LOGIC TRANG M·∫¨T KH·∫®U ---
        (function setupPasswordPage() {
            const passwordDisplay = document.getElementById('password-display');
            const statusMessage = document.getElementById('status-message');
            const keypadButtons = document.querySelectorAll('#password-page .keypad button');
            const correctPassword = '140805';
            let enteredPassword = '';

            keypadButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const key = button.textContent;
                    if (key === '‚úî') {
                        checkPassword();
                    } else if (key === '‚å´') {
                        enteredPassword = enteredPassword.slice(0, -1);
                        updateDisplay();
                    } else if (enteredPassword.length < 6) {
                        enteredPassword += key;
                        updateDisplay();
                    }
                });
            });

            function updateDisplay() {
                passwordDisplay.textContent = '‚Ä¢'.repeat(enteredPassword.length);
            }

            function checkPassword() {
                if (enteredPassword === correctPassword) {
                    statusMessage.textContent = 'Ch√≠nh X√°c!';
                    statusMessage.style.color = 'green';
                    setTimeout(() => {
                        switchPage('birthday-page');
                    }, 1000);
                } else {
                    statusMessage.textContent = 'Sai r·ªìi! Th·ª≠ l·∫°i ƒëi!';
                    statusMessage.style.color = 'red';
                    enteredPassword = '';
                    setTimeout(() => {
                        updateDisplay();
                        statusMessage.textContent = '';
                    }, 1500);
                }
            }
        })();

        // --- LOGIC TRANG SINH NH·∫¨T ---
        function initBirthdayPage() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const letters = 'HAPPYBIRTHDAY';
            const fontSize = 16;
            const columns = canvas.width / fontSize;
            const drops = Array(Math.floor(columns)).fill(1);

            function drawMatrix() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#9c27b0';
                ctx.font = `${fontSize}px monospace`;
                for (let i = 0; i < drops.length; i++) {
                    const text = letters.charAt(Math.floor(Math.random() * letters.length));
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            matrixInterval = setInterval(drawMatrix, 40);

            const greeting1 = document.getElementById('greeting1');
            const greeting2 = document.getElementById('greeting2');
            const greeting3 = document.getElementById('greeting3');
            const giftContainer = document.getElementById('gift');

            setTimeout(() => { greeting1.classList.add('visible'); }, 500);
            setTimeout(() => { greeting1.classList.remove('visible'); }, 3000);
            setTimeout(() => { greeting2.classList.add('visible'); }, 3500);
            setTimeout(() => { greeting2.classList.remove('visible'); }, 6000);
            setTimeout(() => { greeting3.classList.add('visible'); }, 6500);
            setTimeout(() => {
                greeting3.classList.remove('visible');
                clearInterval(matrixInterval); 
                canvas.style.transition = 'opacity 1s';
                canvas.style.opacity = '0';
            }, 9000);
            setTimeout(() => { giftContainer.classList.add('visible'); }, 10000);

            document.getElementById('gift-button').onclick = () => switchPage('galaxy-page');
        }

        // --- LOGIC TRANG V≈® TR·ª§ ---
        function initGalaxyPage() {
            const backgroundMusic = document.getElementById('galaxy-audio');
            if (backgroundMusic) {
                backgroundMusic.play().catch(error => {
                    console.log("L·ªói t·ª± ƒë·ªông ph√°t nh·∫°c:", error);
                });
            }
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('galaxy-canvas'), 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.position.z = 100;

            // ===== BI·∫æN ƒêI·ªÄU KHI·ªÇN =====
            let cameraDistance = 100;
            let cameraAngleX = 0;
            let cameraAngleY = 0;
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let fireworks = [];

            // ===== S·ª∞ KI·ªÜN CHU·ªòT V√Ä TOUCH =====
            const canvas = document.getElementById('galaxy-canvas');
            
            canvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    cameraAngleY += deltaX * 0.01;
                    cameraAngleX -= deltaY * 0.01;
                    cameraAngleX = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleX));
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.1;
                cameraDistance = Math.max(50, Math.min(300, cameraDistance));
            });

            // Touch events
            let touchDistance = 0;
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isMouseDown = true;
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    touchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
                e.preventDefault();
            });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isMouseDown) {
                    const deltaX = e.touches[0].clientX - mouseX;
                    const deltaY = e.touches[0].clientY - mouseY;
                    
                    cameraAngleY += deltaX * 0.01;
                    cameraAngleX -= deltaY * 0.01;
                    cameraAngleX = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleX));
                    
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const newDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const deltaDistance = touchDistance - newDistance;
                    cameraDistance += deltaDistance * 0.3;
                    cameraDistance = Math.max(50, Math.min(300, cameraDistance));
                    touchDistance = newDistance;
                }
                e.preventDefault();
            });

            canvas.addEventListener('touchend', () => {
                isMouseDown = false;
            });

            // ===== ENHANCED PARTICLE TEXTURE - BRIGHTER =====
            function createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                const centerX = 32;
                const centerY = 32;
                const radius = 30;
                
                // Create brighter radial gradient
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.1, 'rgba(255, 255, 255, 1)');   // Larger bright core
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); // Extended brightness
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.7)');
                gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                
                return new THREE.CanvasTexture(canvas);
            }

            // ===== ENHANCED REALISTIC FIREWORK CLASS - BRIGHTER =====
            class RealisticFirework {
                constructor(x, y, z, type = 'normal') {
                    this.particles = [];
                    this.center = new THREE.Vector3(x, y, z);
                    this.age = 0;
                    this.maxAge = 4; // Longer duration
                    this.type = type;
                    this.particleTexture = createParticleTexture();
                    
                    let particleCount, colors, spreadFactor, particleSize;
                    
                    switch (type) {
                        case 'large':
                            particleCount = 40; // More particles
                            colors = [0xffffff, 0xffd700, 0xffff00, 0xffa500]; // Brighter colors
                            spreadFactor = 50;
                            particleSize = 5;
                            this.maxAge = 5;
                            break;
                        case 'small':
                            particleCount = 15;
                            colors = [0xffffff, 0xff69b4, 0xff1493, 0xffc0cb];
                            spreadFactor = 30;
                            particleSize = 3;
                            break;
                        case 'heart':
                            particleCount = 25;
                            colors = [0xffffff, 0xff1493, 0xff69b4, 0xff00ff];
                            spreadFactor = 35;
                            particleSize = 4;
                            break;
                        default:
                            particleCount = 30; // More particles
                            colors = [0xffffff, 0x00ffff, 0x88ffff, 0xaaffff]; // Brighter blues/whites
                            spreadFactor = 40;
                            particleSize = 4;
                    }
                    
                    for (let i = 0; i < particleCount; i++) {
                        let velocity;
                        
                        if (type === 'heart') {
                            // Heart shape pattern
                            const t = (i / particleCount) * Math.PI * 2;
                            const heartX = 16 * Math.pow(Math.sin(t), 3);
                            const heartY = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                            velocity = new THREE.Vector3(heartX * 0.7, heartY * 0.7, (Math.random() - 0.5) * 10);
                        } else {
                            // Spherical explosion
                            const phi = Math.random() * Math.PI * 2;
                            const theta = Math.acos(2 * Math.random() - 1);
                            const speed = spreadFactor * (0.4 + Math.random() * 0.6);
                            
                            velocity = new THREE.Vector3(
                                Math.sin(theta) * Math.cos(phi) * speed,
                                Math.sin(theta) * Math.sin(phi) * speed,
                                Math.cos(theta) * speed
                            );
                        }
                        
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        
                        // Create brighter sprite material
                        const material = new THREE.SpriteMaterial({
                            map: this.particleTexture,
                            color: color,
                            transparent: true,
                            opacity: 1,
                            blending: THREE.AdditiveBlending,
                            alphaTest: 0.001
                        });
                        
                        const sprite = new THREE.Sprite(material);
                        sprite.position.copy(this.center);
                        sprite.scale.setScalar(particleSize);
                        
                        const particle = {
                            sprite: sprite,
                            velocity: velocity,
                            life: 1.0,
                            decay: 0.2 + Math.random() * 0.1, // Slower decay
                            originalLife: 1.0,
                            initialSize: particleSize,
                            twinkleSpeed: 6 + Math.random() * 8,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                        
                        this.particles.push(particle);
                        scene.add(sprite);
                    }
                    
                    // Brighter central light burst
                    this.light = new THREE.PointLight(colors[0], 8, 200); // Brighter intensity
                    this.light.position.copy(this.center);
                    scene.add(this.light);
                }
                
                update(deltaTime) {
                    this.age += deltaTime;
                    
                    // Update light intensity - brighter and longer lasting
                    if (this.light) {
                        const lightLife = Math.max(0, 1 - (this.age / (this.maxAge * 0.4)));
                        this.light.intensity = 8 * lightLife * lightLife;
                        
                        if (this.light.intensity <= 0.2) {
                            scene.remove(this.light);
                            this.light = null;
                        }
                    }
                    
                    this.particles = this.particles.filter(particle => {
                        // Update position
                        particle.sprite.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Apply physics
                        particle.velocity.multiplyScalar(0.99); // Less air resistance
                        particle.velocity.y -= 20 * deltaTime; // Reduced gravity
                        
                        // Update life
                        particle.life -= particle.decay * deltaTime;
                        
                        if (particle.life <= 0) {
                            scene.remove(particle.sprite);
                            return false;
                        }
                        
                        // Enhanced brightness and twinkle effects
                        const fadeOpacity = Math.pow(particle.life, 1.2); // Less harsh fade
                        const twinkle = 0.8 + 0.2 * Math.sin(Date.now() * particle.twinkleSpeed * 0.001 + particle.twinkleOffset);
                        particle.sprite.material.opacity = fadeOpacity * twinkle;
                        
                        // Scale effect - particles shrink as they fade
                        const scaleLife = 0.4 + 0.6 * particle.life;
                        particle.sprite.scale.setScalar(particle.initialSize * scaleLife);
                        
                        return true;
                    });
                    
                    return this.particles.length > 0 || (this.light && this.light.intensity > 0.2);
                }
            }

            // Create brighter star texture
            function createStarTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                
                const centerX = 16;
                const centerY = 16;
                
                // Create brighter star glow effect
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 16);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.2, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 32, 32);
                
                return new THREE.CanvasTexture(canvas);
            }

            // Gi·ªØ l·∫°i h·ªá th·ªëng √°nh s√°ng c≈© ƒë·ªÉ chi·∫øu s√°ng kh√¥ng gian
            const sunLight = new THREE.DirectionalLight(0xFFB6C1, 2.5);
            sunLight.position.set(100, 50, 50);
            scene.add(sunLight);

            const centerSparkleLight = new THREE.PointLight(0xFF69B4, 4, 100);
            centerSparkleLight.position.set(0, 0, 0);
            scene.add(centerSparkleLight);

           // T·∫°o ch√≤m sao S∆∞ T·ª≠ ch√≠nh x√°c theo h√¨nh ·∫£nh thi√™n vƒÉn th·ª±c t·∫ø
            const starTexture = createStarTexture();
            const leoConstellationGroup = new THREE.Group();
            
            const leoStars = [
                // Ph·∫ßn "L∆∞·ª°i h√°i" (ƒê·∫ßu S∆∞ T·ª≠)
                { name: 'Epsilon Leonis', x: 55, y: -5, z: 0, size: 3.5, brightness: 0.9 },    // V·ªã tr√≠ 0
                { name: 'Mu Leonis',      x: 55, y: 10, z: 0, size: 3.2, brightness: 0.85 },   // V·ªã tr√≠ 1
                { name: 'Zeta Leonis',    x: 25, y: 10,  z: 0, size: 3.8, brightness: 0.95 },   // V·ªã tr√≠ 2
                { name: 'Gamma Leonis',   x: 20, y: -2, z: 0, size: 3.4, brightness: 0.9 },    // V·ªã tr√≠ 3
                { name: 'Eta Leonis',     x: 22,  y: -15, z: 0, size: 3.1, brightness: 0.85 },  // V·ªã tr√≠ 4
                { name: 'Alpha Leonis',   x: 15,  y: -30, z: 0, size: 4.8, brightness: 1.0 },   // V·ªã tr√≠ 5

                // Ph·∫ßn Th√¢n
                { name: 'Theta Leonis',   x: -30, y:5,  z: 0, size: 3.2, brightness: 0.85 },    // V·ªã tr√≠ 6
                // Delta Leonis ƒë√£ b·ªã x√≥a
                { name: 'Beta Leonis',    x: -50, y: 18, z: 0, size: 4.2, brightness: 1.0 },    // V·ªã tr√≠ 7 (tr∆∞·ªõc l√† 8)

                // Sao ph·ª•
                { name: 'Rho Leonis',     x: -20, y: 15, z: 0, size: 2.8, brightness: 0.7 },    // V·ªã tr√≠ 8 (tr∆∞·ªõc l√† 9)
            ];

            // T·∫°o c√°c ng√¥i sao v·ªõi hi·ªáu ·ª©ng s√°ng h∆°n
            leoStars.forEach(starData => {
                const starMaterial = new THREE.SpriteMaterial({
                    map: starTexture,
                    color: 0xffffff,
                    transparent: true,
                    opacity: starData.brightness,
                    blending: THREE.AdditiveBlending
                });
                const star = new THREE.Sprite(starMaterial);
                star.position.set(starData.x, starData.y, starData.z);
                star.scale.setScalar(starData.size);
                leoConstellationGroup.add(star);
            });

        const connections = [
            // V·∫Ω "L∆∞·ª°i h√°i" - ph·∫ßn ƒë·∫ßu s∆∞ t·ª≠ (d·∫•u h·ªèi ng∆∞·ª£c ho√†n ch·ªânh)
            [0, 1], // Epsilon ‚Üí Mu
            [1, 2], // Mu ‚Üí Zeta (ƒëi·ªÉm g√£y)
            [2, 3], // Zeta ‚Üí Gamma (cong m·∫°nh)
            [3, 4], // Gamma ‚Üí Eta
            [4, 5], // Eta ‚Üí Alpha (Regulus - ƒëi·ªÉm cu·ªëi)
            
            // N·ªëi t·ª´ ƒë·∫ßu s∆∞ t·ª≠ ƒë·∫øn th√¢n
            [5, 6], // Alpha (Regulus) ‚Üí Theta (n·ªëi tr·ª±c ti·∫øp)
            [3, 8], // Gamma ‚Üí Rho (ƒë√£ c·∫≠p nh·∫≠t index c·ªßa Rho t·ª´ 9 -> 8)
            
            // V·∫Ω ph·∫ßn th√¢n ƒë√£ ƒë∆∞·ª£c ƒë∆°n gi·∫£n h√≥a
            [6, 7], // N·ªëi tr·ª±c ti·∫øp Theta (6) ‚Üí Beta (nay l√† 7)
            
            // ƒê∆∞·ªùng n·ªëi sao ph·ª•
            [8, 7]  // Rho (nay l√† 8) ‚Üí Beta (nay l√† 7)
        ];

            connections.forEach(connection => {
                const start = leoStars[connection[0]];
                const end = leoStars[connection[1]];
                
                const points = [
                    new THREE.Vector3(start.x, start.y, start.z),
                    new THREE.Vector3(end.x, end.y, end.z)
                ];
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                leoConstellationGroup.add(line);
            });
            // Xoay to√†n b·ªô ch√≤m sao 90 ƒë·ªô quanh tr·ª•c Z (tr·ª•c h∆∞·ªõng v·ªÅ ph√≠a ng∆∞·ªùi xem)
            leoConstellationGroup.rotation.z = Math.PI / 2; // Math.PI / 2 t∆∞∆°ng ƒë∆∞∆°ng 90 ƒë·ªô
            scene.add(leoConstellationGroup);

            // Enhanced starfield with romantic circular stars
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 12000;
            const starPositions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                // Position
                starPositions[i * 3] = (Math.random() - 0.5) * 2000;
                starPositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                starPositions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
                
                // Random sizes for realism
                starSizes[i] = Math.random() * 2.5 + 0.8; // Slightly bigger
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({ 
                map: starTexture,
                size: 2.2, // Brighter stars
                sizeAttenuation: false,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                vertexColors: false,
                color: 0xffffff
            });
            const starMesh = new THREE.Points(starGeometry, starMaterial);
            scene.add(starMesh);

            // Optimized firework management with brighter realistic effects
            let fireworkTimer = 0;
            const fireworkSchedule = [
                { time: 2, type: 'normal', count: 1 },
                { time: 4, type: 'large', count: 1 },
                { time: 6, type: 'small', count: 2 },
                { time: 7.5, type: 'heart', count: 1 },
                { time: 9, type: 'normal', count: 2 },
                { time: 11, type: 'large', count: 1 }
            ];
            let scheduleIndex = 0;

            function createFirework(type = 'normal') {
                const x = (Math.random() - 0.5) * 180;
                const y = 40 + Math.random() * 50;
                const z = (Math.random() - 0.5) * 180;
                fireworks.push(new RealisticFirework(x, y, z, type));
            }

            // Enhanced burst firework function
            function createFireworkBurst() {
                const centerX = (Math.random() - 0.5) * 100;
                const centerY = 60 + Math.random() * 30;
                const centerZ = (Math.random() - 0.5) * 100;
                
                const types = ['normal', 'small', 'large', 'heart'];
                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        const offsetX = centerX + (Math.random() - 0.5) * 40;
                        const offsetY = centerY + (Math.random() - 0.5) * 20;
                        const offsetZ = centerZ + (Math.random() - 0.5) * 40;
                        fireworks.push(new RealisticFirework(offsetX, offsetY, offsetZ, types[i % types.length]));
                    }, i * 250);
                }
            }

            // Schedule special burst every 12 seconds (more frequent)
            setInterval(createFireworkBurst, 12000);

            // Create image layers with SLOWER movement
            const imageGroups = [];
            const layers = [
                // T·ªëc ƒë·ªô c≈© l√† 0.003, gi·∫£m c√≤n 0.0015
                { count: 20, radius: 45, speed: 0.0015, size: [4, 6] },

                // T·ªëc ƒë·ªô c≈© l√† -0.002, gi·∫£m c√≤n -0.001
                { count: 25, radius: 70, speed: -0.001, size: [3, 5] }, 

                // T·ªëc ƒë·ªô c≈© l√† 0.0015, gi·∫£m c√≤n 0.0007
                { count: 30, radius: 95, speed: 0.0007, size: [2, 4] } 
            ];

            function createImageLayers() {
                if (!globalTexture) {
                    console.log("Ch∆∞a c√≥ texture cho Galaxy, ƒëang ch·ªù...");
                    setTimeout(createImageLayers, 500);
                    return;
                }

                layers.forEach(layer => {
                    const imageGroup = new THREE.Group();
                    
                    for (let i = 0; i < layer.count; i++) {
                        const material = new THREE.SpriteMaterial({ 
                            map: globalTexture,
                            transparent: true,
                            opacity: 0.85 // Slightly more visible
                        });
                        const sprite = new THREE.Sprite(material);
                        
                        const angle = (i / layer.count) * Math.PI * 2;
                        const radiusVar = layer.radius + (Math.random() - 0.5) * 15;
                        const height = (Math.random() - 0.5) * 20;
                        
                        sprite.position.set(
                            Math.cos(angle) * radiusVar,
                            height,
                            Math.sin(angle) * radiusVar
                        );
                        
                        const scale = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                        sprite.scale.set(scale, scale, scale);
                        
                        sprite.userData = {
                            originalOpacity: material.opacity,
                            twinkleSpeed: 0.5 + Math.random() * 1, // Slower twinkling
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                        
                        imageGroup.add(sprite);
                    }
                    
                    imageGroup.userData = { rotationSpeed: layer.speed };
                    imageGroups.push(imageGroup);
                    scene.add(imageGroup);
                });
            }

            setTimeout(createImageLayers, 1000); // B·∫Øt ƒë·∫ßu t·∫°o layer ·∫£nh sau 1s

            // Enhanced romantic lighting effects
            const colorfulLights = [];
            const lightColors = [0xFF69B4, 0xFFB6C1, 0xFFC0CB, 0xFF1493]; // All pink tones
            lightColors.forEach((color, index) => {
                const light = new THREE.PointLight(color, 2, 600); // Brighter intensity
                const angle = (index / lightColors.length) * Math.PI * 2;
                light.position.set(
                    Math.cos(angle) * 150,
                    Math.sin(index * 0.7) * 50,
                    Math.sin(angle) * 150
                );
                colorfulLights.push(light);
                scene.add(light);
            });

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Slightly brighter ambient
            scene.add(ambientLight);
            
            // 1. H√†m t·∫°o texture (h√¨nh ·∫£nh) cho c√°c ch√πm s√°ng, c√≥ th·ªÉ t√πy ch·ªânh m√†u s·∫Øc
            function createLightBeamTexture(coreColor, haloColor) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; // TƒÉng ƒë·ªô ph√¢n gi·∫£i ƒë·ªÉ c√≥ gradient m∆∞·ª£t h∆°n
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); // L√µi lu√¥n c√≥ m√†u tr·∫Øng s√°ng
                gradient.addColorStop(0.2, coreColor); // M√†u ch√≠nh
                gradient.addColorStop(0.6, haloColor); // V·∫ßng h√†o quang b√™n ngo√†i
                // Chuy·ªÉn m√†u h√†o quang v·ªÅ trong su·ªët ·ªü vi·ªÅn
                const transparentHalo = haloColor.replace(/[^,]+(?=\))/, '0');
                gradient.addColorStop(1, transparentHalo);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 128, 128);
                return new THREE.CanvasTexture(canvas);
            }

            // 2. T·∫°o s·∫µn c√°c texture cho t·ª´ng m√†u s·∫Øc nh∆∞ trong ·∫£nh
            const cyanTexture = createLightBeamTexture('rgba(0, 255, 255, 1)', 'rgba(0, 200, 200, 0.5)');
            const greenTexture = createLightBeamTexture('rgba(173, 255, 47, 1)', 'rgba(0, 200, 0, 0.5)');
            const pinkTexture = createLightBeamTexture('rgba(255, 182, 193, 1)', 'rgba(255, 20, 147, 0.5)');
            
            // 3. T·∫°o ra c√°c ch√πm s√°ng v√† l∆∞u v√†o m·ªôt m·∫£ng
            const lightBeams = [];
            const beamData = [
                // C√°c ch√πm s√°ng m√†u xanh lam (cyan)
                { texture: cyanTexture, radius: 80, speed: 0.25, yAmp: 20 },
                { texture: cyanTexture, radius: 120, speed: -0.2, yAmp: 15 },
                // C√°c ch√πm s√°ng m√†u xanh l√°
                { texture: greenTexture, radius: 100, speed: 0.3, yAmp: -25 },
                { texture: greenTexture, radius: 150, speed: 0.15, yAmp: 10 },
                // C√°c ch√πm s√°ng m√†u h·ªìng
                { texture: pinkTexture, radius: 90, speed: -0.28, yAmp: 22 },
                { texture: pinkTexture, radius: 130, speed: 0.22, yAmp: -18 },
            ];

            beamData.forEach(data => {
                const material = new THREE.SpriteMaterial({
                    map: data.texture,
                    blending: THREE.AdditiveBlending, // Hi·ªáu ·ª©ng c·ªông s√°ng, l√†m cho n√≥ r·ª±c r·ª° h∆°n
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false, // Quan tr·ªçng ƒë·ªÉ c√°c v·∫≠t th·ªÉ trong su·ªët kh√¥ng che nhau sai c√°ch
                });
                const sprite = new THREE.Sprite(material);
                
                const scale = 15 + Math.random() * 10; // K√≠ch th∆∞·ªõc l·ªõn, n·ªïi b·∫≠t h∆°n
                sprite.scale.set(scale, scale, scale);
                
                // L∆∞u tr·ªØ c√°c thu·ªôc t√≠nh di chuy·ªÉn ri√™ng cho m·ªói ch√πm s√°ng
                sprite.userData = {
                    baseRadius: data.radius + (Math.random() - 0.5) * 20, // B√°n k√≠nh qu·ªπ ƒë·∫°o ng·∫´u nhi√™n
                    speed: data.speed * (0.8 + Math.random() * 0.4),      // T·ªëc ƒë·ªô ng·∫´u nhi√™n
                    yAmplitude: data.yAmp + (Math.random() - 0.5) * 10,   // Bi√™n ƒë·ªô l√™n xu·ªëng ng·∫´u nhi√™n
                    yOffset: Math.random() * Math.PI * 2,
                    phaseOffset: Math.random() * Math.PI * 2,             // V·ªã tr√≠ b·∫Øt ƒë·∫ßu ng·∫´u nhi√™n
                    pulseSpeed: 1 + Math.random() * 2                     // T·ªëc ƒë·ªô nh·∫•p nh√°y ng·∫´u nhi√™n
                };
                
                lightBeams.push(sprite);
                scene.add(sprite); // Th√™m ch√πm s√°ng v√†o c·∫£nh
            });

            // Main animation loop
            const clock = new THREE.Clock();
            function animate() {
                galaxyAnimationId = requestAnimationFrame(animate);
                const deltaTime = clock.getDelta();
                const elapsedTime = clock.getElapsedTime();
                
                // Optimized firework management with brighter realistic effects
                fireworkTimer += deltaTime;
                if (scheduleIndex < fireworkSchedule.length && fireworkTimer >= fireworkSchedule[scheduleIndex].time) {
                    const schedule = fireworkSchedule[scheduleIndex];
                    for (let i = 0; i < schedule.count; i++) {
                        setTimeout(() => createFirework(schedule.type), i * 300);
                    }
                    scheduleIndex++;
                }
                
                // Reset schedule when complete
                if (scheduleIndex >= fireworkSchedule.length && fireworkTimer > 13) {
                    fireworkTimer = 0;
                    scheduleIndex = 0;
                }

                // Chuy·ªÉn ƒë·ªông cho c√°c ƒë·ªëi t∆∞·ª£ng
                starMesh.rotation.y += 0.0001; // Gi·∫£m t·ªëc ƒë·ªô quay c·ªßa d·∫£i ng√¢n h√† n·ªÅn
                leoConstellationGroup.rotation.y += 0.0005; 
                
                // Hi·ªáu ·ª©ng nh·∫•p nh√°y cho c√°c ng√¥i sao trong ch√≤m S∆∞ T·ª≠
                leoConstellationGroup.children.forEach((child, index) => {
                    if (child.isSprite) { 
                        const twinkle = 0.7 + 0.3 * Math.sin(elapsedTime * (2 + index * 0.3) + index * 2);
                        child.material.opacity = twinkle;
                    }
                });
                
                // Enhanced romantic lighting effects
                centerSparkleLight.intensity = 3.5 + Math.sin(elapsedTime * 3) * 1.5;
                
                // Animate romantic lights with more natural movement - SLOWER
                colorfulLights.forEach((light, index) => {
                    const angle = elapsedTime * 0.08 + (index * Math.PI * 2 / colorfulLights.length); // Much slower
                    light.position.x = Math.cos(angle) * (140 + Math.sin(elapsedTime * 0.5 + index) * 20);
                    light.position.z = Math.sin(angle) * (140 + Math.cos(elapsedTime * 0.5 + index) * 20);
                    light.position.y = Math.sin(elapsedTime * 0.3 + index) * 30; // Slower vertical movement
                    light.intensity = 1.8 + Math.sin(elapsedTime * 2 + index * 1.5) * 1; // Brighter
                });

                // Enhanced star twinkling
                starMaterial.opacity = 0.9 + 0.1 * Math.sin(elapsedTime * 0.3); // Brighter, slower twinkle

                // Image layer animations with MUCH slower movement and improved effects
                imageGroups.forEach(group => {
                    group.rotation.y += group.userData.rotationSpeed;
                    group.children.forEach(sprite => {
                        const twinkle = Math.sin(elapsedTime * sprite.userData.twinkleSpeed + sprite.userData.twinkleOffset);
                        sprite.material.opacity = sprite.userData.originalOpacity + twinkle * 0.15;
                    });
                });

                // C·∫≠p nh·∫≠t v·ªã tr√≠ c√°c ch√πm s√°ng
                lightBeams.forEach(beam => {
                    // T√≠nh to√°n v·ªã tr√≠ m·ªõi d·ª±a tr√™n th·ªùi gian ƒë√£ tr√¥i qua ƒë·ªÉ t·∫°o qu·ªπ ƒë·∫°o
                    const t = elapsedTime * beam.userData.speed + beam.userData.phaseOffset;
                    beam.position.x = beam.userData.baseRadius * Math.cos(t);
                    beam.position.z = beam.userData.baseRadius * Math.sin(t);
                    beam.position.y = beam.userData.yAmplitude * Math.sin(t * 1.5 + beam.userData.yOffset); // Chuy·ªÉn ƒë·ªông l√™n xu·ªëng m∆∞·ª£t h∆°n

                    // Th√™m hi·ªáu ·ª©ng nh·∫•p nh√°y/thay ƒë·ªïi ƒë·ªô s√°ng
                    beam.material.opacity = 0.6 + 0.4 * Math.sin(elapsedTime * beam.userData.pulseSpeed);
                });
                
                // Update camera position
                camera.position.x = Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
                camera.position.y = Math.sin(cameraAngleX) * cameraDistance;
                camera.position.z = Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
                camera.lookAt(scene.position);
                
                // Update brighter realistic fireworks
                fireworks = fireworks.filter(firework => firework.update(deltaTime));
                
                // Performance management - limit fireworks
                if (fireworks.length > 8) { // Allow more fireworks
                    const oldestFirework = fireworks.shift();
                    if (oldestFirework.light) {
                        scene.remove(oldestFirework.light);
                    }
                    oldestFirework.particles.forEach(particle => {
                        scene.remove(particle.sprite);
                    });
                }
                
                renderer.render(scene, camera);
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
