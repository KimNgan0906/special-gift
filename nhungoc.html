<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Món quà đặc biệt</title>
    <!-- Thư viện Three.js để vẽ 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playpen+Sans:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* ---- General Styling ---- */
        body {
            margin: 0;
            font-family: 'Playpen Sans', cursive;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
        }

        /* ---- Page Switching Logic ---- */
        .page {
            display: none;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .page.active {
            display: flex;
        }
        
        /* ---- Password Page ---- */
        #password-page {
            background-color: #f0f0f0;
        }
        
        .container {
            text-align: center;
            background-color: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-family: 'Playpen Sans', cursive;
            color: rgb(0, 0, 0);
            font-size: 32px;
            margin-bottom: 30px;
            text-shadow: 0 4px 4px rgba(145, 145, 145, 0.7);
        }

        .password-wrapper {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .password-image {
            width: 150px;
            height: 150px;
            background-color: #f5f5f5;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed #ddd;
        }

        .password-image img {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            object-fit: cover;
            display: none; /* Ẩn cho đến khi load xong */
        }

        .password-image img.loaded {
            display: block;
        }

        .placeholder-text {
            color: #999;
            font-size: 14px;
            text-align: center;
        }

        .password-input-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #password-display {
            width: 100%;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 30px;
            letter-spacing: 10px;
            text-align: center;
            line-height: 40px;
            color: #333;
        }

        .keypad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .keypad button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background-color: #f9f9f9;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .keypad button:hover {
            background-color: #e0e0e0;
        }

        .keypad button:active {
            transform: scale(0.95);
        }

        #status-message {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            height: 20px;
        }

        /* ---- Birthday Page ---- */
        #birthday-page {
            position: relative;
        }
        
        #matrix-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .greeting-container {
            position: relative;
            z-index: 2;
            color: white;
            font-size: 8vw;
            font-weight: bold;
            text-shadow: 0 0 15px #fff, 0 0 25px #fff;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
            position: absolute;
        }

        .greeting-container.visible {
            opacity: 1;
        }
        
        .gift-container {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            visibility: hidden;
        }

        .gift-container.visible {
            opacity: 1;
            visibility: visible;
        }

        .gift-container img {
            width: 250px;
            height: 250px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.7);
        }

        .gift-container button {
            font-family: 'Playpen Sans', cursive;
            padding: 15px 30px;
            font-size: 20px;
            border: none;
            border-radius: 50px;
            background-color: #ff69b4;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 20px #ff69b4;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .gift-container button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px #ff69b4;
        }
        
        /* ---- Galaxy Page ---- */
        #galaxy-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #galaxy-canvas:active {
            cursor: grabbing;
        }

        .galaxy-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            backdrop-filter: blur(5px);
            max-width: 200px;
        }

        .control-item {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-icon {
            font-size: 16px;
            width: 20px;
        }

        /* Error message styling */
        .error-message {
            color: #ff6b6b;
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- ======================= PAGE 1: MẬT KHẨU ======================= -->
    <div id="password-page" class="page active">
        <div class="container">
            <h1>NHẬP PASS ĐI NGƯỜI ĐẸP</h1>
            <div class="password-wrapper">
                <div class="password-image">
                    <img id="girl-img-1" alt="Ảnh 1">
                    <div class="placeholder-text" id="img-placeholder-1">
                        Đang tải ảnh...<br>
                        <small>Đặt file 1.png trong cùng thư mục</small>
                    </div>
                </div>
                <div class="password-input-area">
                    <div id="password-display"></div>
                    <div class="keypad">
                        <button>1</button><button>2</button><button>3</button>
                        <button>4</button><button>5</button><button>6</button>
                        <button>7</button><button>8</button><button>9</button>
                        <button id="submit">✔</button><button>0</button><button id="delete">⌫</button>
                    </div>
                    <div id="status-message"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ======================= PAGE 2: CHÚC MỪNG ======================= -->
    <div id="birthday-page" class="page">
        <canvas id="matrix-canvas"></canvas>
        <div id="greeting1" class="greeting-container">Chúc mừng</div>
        <div id="greeting2" class="greeting-container">sinh nhật</div>
        <div id="greeting3" class="greeting-container">bạn yêu</div>
        <div id="gift" class="gift-container">
            <img id="girl-img-2" alt="Ảnh 2">
            <button id="gift-button">Quà nè</button>
        </div>
    </div>

    <!-- ======================= PAGE 3: VŨ TRỤ ======================= -->
    <div id="galaxy-page" class="page">
         <canvas id="galaxy-canvas"></canvas>
    </div>

    <!-- Audio element -->
    <audio id="galaxy-audio" src="traoem1.MP3" loop></audio>

    <script>
        // --- CẤU HÌNH ĐƯỜNG DẪN ẢNH CHO TỪNG TRANG ---
        const imagePathsPage1 = [
            './login1.jpg', './img/1.png', 'img/1.png', '../1.png', 
            'https://picsum.photos/200/200?random=1'
        ];
        const imagePathsPage2 = [
            './chucmung.jpg', './img/2.png', 'img/2.png', '../2.png', 
            'https://picsum.photos/250/250?random=2'
        ];
        const imagePathsPage3 = [
            './galaxy.jpg', './img/3.png', 'img/3.png', '../3.png',
            'https://picsum.photos/200/200?random=3'
        ];

        // Biến global để lưu texture cho trang vũ trụ
        let globalTexture = null;

        // Hàm tải ảnh với fallback (cho thẻ <img> của HTML)
        function loadImageWithFallback(imgElement, placeholderElement, paths, imageName, index = 0) {
            if (index >= paths.length) {
                if (placeholderElement) {
                    placeholderElement.innerHTML = `
                        ❌ Không tìm thấy ảnh!<br>
                        <small style="color: #666;">
                            Hãy đặt file "${imageName}" vào:<br>
                            - Cùng thư mục với file HTML<br>
                            - Hoặc trong thư mục "img/"
                        </small>
                    `;
                }
                return;
            }

            const currentPath = paths[index];
            const testImg = new Image();
            
            testImg.onload = function() {
                imgElement.src = currentPath;
                imgElement.classList.add('loaded');
                if (placeholderElement) {
                    placeholderElement.style.display = 'none';
                }
                console.log(`✅ Đã tải ảnh ${imageName} từ: ${currentPath}`);
            };
            
            testImg.onerror = function() {
                console.log(`❌ Không tìm thấy ảnh tại: ${currentPath}`);
                loadImageWithFallback(imgElement, placeholderElement, paths, imageName, index + 1);
            };
            
            testImg.src = currentPath;
        }

        // Hàm tải texture cho Galaxy (Trang 3) với fallback
        function loadGalaxyTextureWithFallback(paths, index = 0) {
            if (index >= paths.length) {
                console.log('❌ Không tìm thấy ảnh cho Galaxy, tạo texture thay thế.');
                createFallbackTexture();
                return;
            }
            const currentPath = paths[index];
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                currentPath,
                function(texture) { // OnLoad
                    globalTexture = texture;
                    console.log(`✅ Đã tải texture cho Galaxy từ: ${currentPath}`);
                },
                undefined, // onProgress
                function(err) { // onError
                    console.log(`❌ Không tải được texture từ: ${currentPath}`);
                    loadGalaxyTextureWithFallback(paths, index + 1);
                }
            );
        }

        // Tạo texture thay thế khi không có ảnh
        function createFallbackTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, '#ff69b4');
            gradient.addColorStop(0.5, '#9c27b0');
            gradient.addColorStop(1, '#673ab7');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('💖', 32, 20);
            ctx.font = '8px Arial';
            ctx.fillText('BIRTHDAY', 32, 35);
            ctx.fillText('GIFT', 32, 45);
            
            globalTexture = new THREE.CanvasTexture(canvas);
            console.log('✅ Đã tạo fallback texture cho Galaxy');
        }

        // --- Bắt đầu tải các ảnh ---
        // Tải ảnh cho Trang 1
        const img1 = document.getElementById('girl-img-1');
        const placeholder1 = document.getElementById('img-placeholder-1');
        loadImageWithFallback(img1, placeholder1, imagePathsPage1, '1.png');

        // Tải ảnh cho Trang 2
        const img2 = document.getElementById('girl-img-2');
        loadImageWithFallback(img2, null, imagePathsPage2, '2.png');
        
        // Tải texture cho Trang 3 (Galaxy)
        loadGalaxyTextureWithFallback(imagePathsPage3);


        // --- LOGIC CHUYỂN TRANG ---
        let matrixInterval;
        let galaxyAnimationId;

        function switchPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');

            if (pageId === 'birthday-page') {
                initBirthdayPage();
            } else if (pageId === 'galaxy-page') {
                if (matrixInterval) clearInterval(matrixInterval);
                if (galaxyAnimationId) cancelAnimationFrame(galaxyAnimationId);
                initGalaxyPage();
            }
        }

        // --- LOGIC TRANG MẬT KHẨU ---
        (function setupPasswordPage() {
            const passwordDisplay = document.getElementById('password-display');
            const statusMessage = document.getElementById('status-message');
            const keypadButtons = document.querySelectorAll('#password-page .keypad button');
            const correctPassword = '140805';
            let enteredPassword = '';

            keypadButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const key = button.textContent;
                    if (key === '✔') {
                        checkPassword();
                    } else if (key === '⌫') {
                        enteredPassword = enteredPassword.slice(0, -1);
                        updateDisplay();
                    } else if (enteredPassword.length < 6) {
                        enteredPassword += key;
                        updateDisplay();
                    }
                });
            });

            function updateDisplay() {
                passwordDisplay.textContent = '•'.repeat(enteredPassword.length);
            }

            function checkPassword() {
                if (enteredPassword === correctPassword) {
                    statusMessage.textContent = 'Chính Xác!';
                    statusMessage.style.color = 'green';
                    setTimeout(() => {
                        switchPage('birthday-page');
                    }, 1000);
                } else {
                    statusMessage.textContent = 'Sai rồi! Thử lại đi!';
                    statusMessage.style.color = 'red';
                    enteredPassword = '';
                    setTimeout(() => {
                        updateDisplay();
                        statusMessage.textContent = '';
                    }, 1500);
                }
            }
        })();

        // --- LOGIC TRANG SINH NHẬT ---
        function initBirthdayPage() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const letters = 'HAPPYBIRTHDAY';
            const fontSize = 16;
            const columns = canvas.width / fontSize;
            const drops = Array(Math.floor(columns)).fill(1);

            function drawMatrix() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#9c27b0';
                ctx.font = `${fontSize}px monospace`;
                for (let i = 0; i < drops.length; i++) {
                    const text = letters.charAt(Math.floor(Math.random() * letters.length));
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            matrixInterval = setInterval(drawMatrix, 40);

            const greeting1 = document.getElementById('greeting1');
            const greeting2 = document.getElementById('greeting2');
            const greeting3 = document.getElementById('greeting3');
            const giftContainer = document.getElementById('gift');

            setTimeout(() => { greeting1.classList.add('visible'); }, 500);
            setTimeout(() => { greeting1.classList.remove('visible'); }, 3000);
            setTimeout(() => { greeting2.classList.add('visible'); }, 3500);
            setTimeout(() => { greeting2.classList.remove('visible'); }, 6000);
            setTimeout(() => { greeting3.classList.add('visible'); }, 6500);
            setTimeout(() => {
                greeting3.classList.remove('visible');
                clearInterval(matrixInterval); 
                canvas.style.transition = 'opacity 1s';
                canvas.style.opacity = '0';
            }, 9000);
            setTimeout(() => { giftContainer.classList.add('visible'); }, 10000);

            document.getElementById('gift-button').onclick = () => switchPage('galaxy-page');
        }

        // --- LOGIC TRANG VŨ TRỤ ---
        function initGalaxyPage() {
            const backgroundMusic = document.getElementById('galaxy-audio');
            if (backgroundMusic) {
                backgroundMusic.play().catch(error => {
                    console.log("Lỗi tự động phát nhạc:", error);
                });
            }
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('galaxy-canvas'), 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.position.z = 100;

            // ===== BIẾN ĐIỀU KHIỂN =====
            let cameraDistance = 100;
            let cameraAngleX = 0;
            let cameraAngleY = 0;
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let fireworks = [];

            // ===== SỰ KIỆN CHUỘT VÀ TOUCH =====
            const canvas = document.getElementById('galaxy-canvas');
            
            canvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    cameraAngleY += deltaX * 0.01;
                    cameraAngleX -= deltaY * 0.01;
                    cameraAngleX = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleX));
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.1;
                cameraDistance = Math.max(50, Math.min(300, cameraDistance));
            });

            // Touch events
            let touchDistance = 0;
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isMouseDown = true;
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    touchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
                e.preventDefault();
            });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isMouseDown) {
                    const deltaX = e.touches[0].clientX - mouseX;
                    const deltaY = e.touches[0].clientY - mouseY;
                    
                    cameraAngleY += deltaX * 0.01;
                    cameraAngleX -= deltaY * 0.01;
                    cameraAngleX = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleX));
                    
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const newDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const deltaDistance = touchDistance - newDistance;
                    cameraDistance += deltaDistance * 0.3;
                    cameraDistance = Math.max(50, Math.min(300, cameraDistance));
                    touchDistance = newDistance;
                }
                e.preventDefault();
            });

            canvas.addEventListener('touchend', () => {
                isMouseDown = false;
            });

            // ===== ENHANCED PARTICLE TEXTURE - BRIGHTER =====
            function createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                const centerX = 32;
                const centerY = 32;
                const radius = 30;
                
                // Create brighter radial gradient
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.1, 'rgba(255, 255, 255, 1)');   // Larger bright core
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); // Extended brightness
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.7)');
                gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                
                return new THREE.CanvasTexture(canvas);
            }

            // ===== ENHANCED REALISTIC FIREWORK CLASS - BRIGHTER =====
            class RealisticFirework {
                constructor(x, y, z, type = 'normal') {
                    this.particles = [];
                    this.center = new THREE.Vector3(x, y, z);
                    this.age = 0;
                    this.maxAge = 4; // Longer duration
                    this.type = type;
                    this.particleTexture = createParticleTexture();
                    
                    let particleCount, colors, spreadFactor, particleSize;
                    
                    switch (type) {
                        case 'large':
                            particleCount = 40; // More particles
                            colors = [0xffffff, 0xffd700, 0xffff00, 0xffa500]; // Brighter colors
                            spreadFactor = 50;
                            particleSize = 5;
                            this.maxAge = 5;
                            break;
                        case 'small':
                            particleCount = 15;
                            colors = [0xffffff, 0xff69b4, 0xff1493, 0xffc0cb];
                            spreadFactor = 30;
                            particleSize = 3;
                            break;
                        case 'heart':
                            particleCount = 25;
                            colors = [0xffffff, 0xff1493, 0xff69b4, 0xff00ff];
                            spreadFactor = 35;
                            particleSize = 4;
                            break;
                        default:
                            particleCount = 30; // More particles
                            colors = [0xffffff, 0x00ffff, 0x88ffff, 0xaaffff]; // Brighter blues/whites
                            spreadFactor = 40;
                            particleSize = 4;
                    }
                    
                    for (let i = 0; i < particleCount; i++) {
                        let velocity;
                        
                        if (type === 'heart') {
                            // Heart shape pattern
                            const t = (i / particleCount) * Math.PI * 2;
                            const heartX = 16 * Math.pow(Math.sin(t), 3);
                            const heartY = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                            velocity = new THREE.Vector3(heartX * 0.7, heartY * 0.7, (Math.random() - 0.5) * 10);
                        } else {
                            // Spherical explosion
                            const phi = Math.random() * Math.PI * 2;
                            const theta = Math.acos(2 * Math.random() - 1);
                            const speed = spreadFactor * (0.4 + Math.random() * 0.6);
                            
                            velocity = new THREE.Vector3(
                                Math.sin(theta) * Math.cos(phi) * speed,
                                Math.sin(theta) * Math.sin(phi) * speed,
                                Math.cos(theta) * speed
                            );
                        }
                        
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        
                        // Create brighter sprite material
                        const material = new THREE.SpriteMaterial({
                            map: this.particleTexture,
                            color: color,
                            transparent: true,
                            opacity: 1,
                            blending: THREE.AdditiveBlending,
                            alphaTest: 0.001
                        });
                        
                        const sprite = new THREE.Sprite(material);
                        sprite.position.copy(this.center);
                        sprite.scale.setScalar(particleSize);
                        
                        const particle = {
                            sprite: sprite,
                            velocity: velocity,
                            life: 1.0,
                            decay: 0.2 + Math.random() * 0.1, // Slower decay
                            originalLife: 1.0,
                            initialSize: particleSize,
                            twinkleSpeed: 6 + Math.random() * 8,
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                        
                        this.particles.push(particle);
                        scene.add(sprite);
                    }
                    
                    // Brighter central light burst
                    this.light = new THREE.PointLight(colors[0], 8, 200); // Brighter intensity
                    this.light.position.copy(this.center);
                    scene.add(this.light);
                }
                
                update(deltaTime) {
                    this.age += deltaTime;
                    
                    // Update light intensity - brighter and longer lasting
                    if (this.light) {
                        const lightLife = Math.max(0, 1 - (this.age / (this.maxAge * 0.4)));
                        this.light.intensity = 8 * lightLife * lightLife;
                        
                        if (this.light.intensity <= 0.2) {
                            scene.remove(this.light);
                            this.light = null;
                        }
                    }
                    
                    this.particles = this.particles.filter(particle => {
                        // Update position
                        particle.sprite.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Apply physics
                        particle.velocity.multiplyScalar(0.99); // Less air resistance
                        particle.velocity.y -= 20 * deltaTime; // Reduced gravity
                        
                        // Update life
                        particle.life -= particle.decay * deltaTime;
                        
                        if (particle.life <= 0) {
                            scene.remove(particle.sprite);
                            return false;
                        }
                        
                        // Enhanced brightness and twinkle effects
                        const fadeOpacity = Math.pow(particle.life, 1.2); // Less harsh fade
                        const twinkle = 0.8 + 0.2 * Math.sin(Date.now() * particle.twinkleSpeed * 0.001 + particle.twinkleOffset);
                        particle.sprite.material.opacity = fadeOpacity * twinkle;
                        
                        // Scale effect - particles shrink as they fade
                        const scaleLife = 0.4 + 0.6 * particle.life;
                        particle.sprite.scale.setScalar(particle.initialSize * scaleLife);
                        
                        return true;
                    });
                    
                    return this.particles.length > 0 || (this.light && this.light.intensity > 0.2);
                }
            }

            // Create brighter star texture
            function createStarTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                
                const centerX = 16;
                const centerY = 16;
                
                // Create brighter star glow effect
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 16);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.2, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 32, 32);
                
                return new THREE.CanvasTexture(canvas);
            }

            // ===== ENHANCED LEO PLANET CREATION =====
            function createLeoTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // Create golden-pink gradient background
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
                gradient.addColorStop(0, 'rgba(255, 215, 180, 1)');    // Warm gold-pink center
                gradient.addColorStop(0.3, 'rgba(255, 182, 193, 0.9)'); // Light pink
                gradient.addColorStop(0.7, 'rgba(255, 105, 180, 0.6)'); // Hot pink
                gradient.addColorStop(1, 'rgba(218, 112, 214, 0.3)');   // Orchid fade
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);

                // Add romantic texture pattern
                ctx.globalCompositeOperation = 'overlay';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const size = Math.random() * 3 + 1;
                    ctx.fillStyle = `rgba(255, 192, 203, ${Math.random() * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalCompositeOperation = 'source-over';

                // Draw Leo symbol with romantic styling
                ctx.font = 'bold 300px Arial';
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 8;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#FF1493';
                ctx.shadowBlur = 40;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Draw shadow first
                ctx.fillStyle = 'rgba(255, 20, 147, 0.4)';
                ctx.fillText('♌', 260, 260);
                
                // Draw main symbol
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText('♌', 256, 256);
                ctx.strokeText('♌', 256, 256);

                return new THREE.CanvasTexture(canvas);
            }

            // Create enhanced Leo planet with romantic colors
            const leoTexture = createLeoTexture();
            const planetGeometry = new THREE.SphereGeometry(18, 64, 64);
            const planetMaterial = new THREE.MeshStandardMaterial({
                map: leoTexture,
                emissiveMap: leoTexture,
                emissive: 0xFF69B4, // Pink emissive
                emissiveIntensity: 0.6,
                metalness: 0.1,
                roughness: 0.4,
                transparent: false
            });
            
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            scene.add(planet);

            // Add romantic planetary glow effect
            const glowGeometry = new THREE.SphereGeometry(22, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF69B4, // Pink glow
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            
            const planetGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            scene.add(planetGlow);

            // Enhanced romantic lighting system
            const sunLight = new THREE.DirectionalLight(0xFFB6C1, 2.5); // Light pink
            sunLight.position.set(100, 50, 50);
            scene.add(sunLight);

            const centerSparkleLight = new THREE.PointLight(0xFF69B4, 4, 100); // Pink center light
            centerSparkleLight.position.set(0, 0, 0);
            scene.add(centerSparkleLight);

            // Create realistic star texture and constellation
            const starTexture = createStarTexture();
            const constellationGroup = new THREE.Group();
            const constellationPoints = [
                {x: -8, y: 12, z: 0}, {x: 0, y: 15, z: 0}, {x: 8, y: 12, z: 0},
                {x: 12, y: 5, z: 0}, {x: 10, y: -2, z: 0}, {x: 5, y: -8, z: 0},
                {x: -5, y: -8, z: 0}, {x: -10, y: -2, z: 0}, {x: -12, y: 5, z: 0}
            ];

            constellationPoints.forEach(point => {
                const starMaterial = new THREE.SpriteMaterial({
                    map: starTexture,
                    color: 0xFFB6C1, // Pink stars
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                const star = new THREE.Sprite(starMaterial);
                star.position.set(point.x + 25, point.y, point.z);
                star.scale.setScalar(1.8);
                constellationGroup.add(star);
            });
            scene.add(constellationGroup);

            // Enhanced planetary particles with romantic pink glow
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = 180;
            const posArray = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                const radius = 25 + Math.random() * 15;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.acos(2 * Math.random() - 1);
                
                posArray[i] = radius * Math.sin(theta) * Math.cos(phi);
                posArray[i + 1] = radius * Math.sin(theta) * Math.sin(phi);
                posArray[i + 2] = radius * Math.cos(theta);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particleMaterial = new THREE.PointsMaterial({
                map: createParticleTexture(),
                size: 3.5,
                color: 0xFFB6C1, // Pink particles
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: false
            });
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Enhanced pink ring system
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(22, 0.4, 16, 100),
                new THREE.MeshBasicMaterial({ 
                    color: 0xFFC0CB, // Pink ring
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.7 
                })
            );
            ring.rotation.x = Math.PI / 2.2;
            scene.add(ring);

            // Beautiful moon with romantic texture
            const moonGeometry = new THREE.SphereGeometry(4, 32, 32);
            const moonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF5F5DC, // Romantic beige
                roughness: 0.9,
                metalness: 0.1,
                emissive: 0xFFE4E1, // Misty rose
                emissiveIntensity: 0.1
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moon);

            // Enhanced starfield with romantic circular stars
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 12000;
            const starPositions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                // Position
                starPositions[i * 3] = (Math.random() - 0.5) * 2000;
                starPositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                starPositions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
                
                // Random sizes for realism
                starSizes[i] = Math.random() * 2.5 + 0.8; // Slightly bigger
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({ 
                map: starTexture,
                size: 2.2, // Brighter stars
                sizeAttenuation: false,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                vertexColors: false,
                color: 0xffffff
            });
            const starMesh = new THREE.Points(starGeometry, starMaterial);
            scene.add(starMesh);

            // Optimized firework management with brighter realistic effects
            let fireworkTimer = 0;
            const fireworkSchedule = [
                { time: 2, type: 'normal', count: 1 },
                { time: 4, type: 'large', count: 1 },
                { time: 6, type: 'small', count: 2 },
                { time: 7.5, type: 'heart', count: 1 },
                { time: 9, type: 'normal', count: 2 },
                { time: 11, type: 'large', count: 1 }
            ];
            let scheduleIndex = 0;

            function createFirework(type = 'normal') {
                const x = (Math.random() - 0.5) * 180;
                const y = 40 + Math.random() * 50;
                const z = (Math.random() - 0.5) * 180;
                fireworks.push(new RealisticFirework(x, y, z, type));
            }

            // Enhanced burst firework function
            function createFireworkBurst() {
                const centerX = (Math.random() - 0.5) * 100;
                const centerY = 60 + Math.random() * 30;
                const centerZ = (Math.random() - 0.5) * 100;
                
                const types = ['normal', 'small', 'large', 'heart'];
                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        const offsetX = centerX + (Math.random() - 0.5) * 40;
                        const offsetY = centerY + (Math.random() - 0.5) * 20;
                        const offsetZ = centerZ + (Math.random() - 0.5) * 40;
                        fireworks.push(new RealisticFirework(offsetX, offsetY, offsetZ, types[i % types.length]));
                    }, i * 250);
                }
            }

            // Schedule special burst every 12 seconds (more frequent)
            setInterval(createFireworkBurst, 12000);

            // Create image layers with SLOWER movement
            const imageGroups = [];
            const layers = [
                // Tốc độ cũ là 0.003, giảm còn 0.0015
                { count: 20, radius: 45, speed: 0.0015, size: [4, 6] },

                // Tốc độ cũ là -0.002, giảm còn -0.001
                { count: 25, radius: 70, speed: -0.001, size: [3, 5] }, 

                // Tốc độ cũ là 0.0015, giảm còn 0.0007
                { count: 30, radius: 95, speed: 0.0007, size: [2, 4] } 
            ];

            function createImageLayers() {
                if (!globalTexture) {
                    console.log("Chưa có texture cho Galaxy, đang chờ...");
                    setTimeout(createImageLayers, 500);
                    return;
                }

                layers.forEach(layer => {
                    const imageGroup = new THREE.Group();
                    
                    for (let i = 0; i < layer.count; i++) {
                        const material = new THREE.SpriteMaterial({ 
                            map: globalTexture,
                            transparent: true,
                            opacity: 0.85 // Slightly more visible
                        });
                        const sprite = new THREE.Sprite(material);
                        
                        const angle = (i / layer.count) * Math.PI * 2;
                        const radiusVar = layer.radius + (Math.random() - 0.5) * 15;
                        const height = (Math.random() - 0.5) * 20;
                        
                        sprite.position.set(
                            Math.cos(angle) * radiusVar,
                            height,
                            Math.sin(angle) * radiusVar
                        );
                        
                        const scale = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                        sprite.scale.set(scale, scale, scale);
                        
                        sprite.userData = {
                            originalOpacity: material.opacity,
                            twinkleSpeed: 0.5 + Math.random() * 1, // Slower twinkling
                            twinkleOffset: Math.random() * Math.PI * 2
                        };
                        
                        imageGroup.add(sprite);
                    }
                    
                    imageGroup.userData = { rotationSpeed: layer.speed };
                    imageGroups.push(imageGroup);
                    scene.add(imageGroup);
                });
            }

            setTimeout(createImageLayers, 1000); // Bắt đầu tạo layer ảnh sau 1s

            // Enhanced romantic lighting effects
            const colorfulLights = [];
            const lightColors = [0xFF69B4, 0xFFB6C1, 0xFFC0CB, 0xFF1493]; // All pink tones
            lightColors.forEach((color, index) => {
                const light = new THREE.PointLight(color, 2, 600); // Brighter intensity
                const angle = (index / lightColors.length) * Math.PI * 2;
                light.position.set(
                    Math.cos(angle) * 150,
                    Math.sin(index * 0.7) * 50,
                    Math.sin(angle) * 150
                );
                colorfulLights.push(light);
                scene.add(light);
            });

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Slightly brighter ambient
            scene.add(ambientLight);
            
            // =======================================================================
            // ===== BẮT ĐẦU PHẦN CODE MỚI: CÁC CHÙM ÁNH SÁNG NHIỀU MÀU SẮC ========
            // =======================================================================

            // 1. Hàm tạo texture (hình ảnh) cho các chùm sáng, có thể tùy chỉnh màu sắc
            function createLightBeamTexture(coreColor, haloColor) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; // Tăng độ phân giải để có gradient mượt hơn
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); // Lõi luôn có màu trắng sáng
                gradient.addColorStop(0.2, coreColor); // Màu chính
                gradient.addColorStop(0.6, haloColor); // Vầng hào quang bên ngoài
                // Chuyển màu hào quang về trong suốt ở viền
                const transparentHalo = haloColor.replace(/[^,]+(?=\))/, '0');
                gradient.addColorStop(1, transparentHalo);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 128, 128);
                return new THREE.CanvasTexture(canvas);
            }

            // 2. Tạo sẵn các texture cho từng màu sắc như trong ảnh
            const cyanTexture = createLightBeamTexture('rgba(0, 255, 255, 1)', 'rgba(0, 200, 200, 0.5)');
            const greenTexture = createLightBeamTexture('rgba(173, 255, 47, 1)', 'rgba(0, 200, 0, 0.5)');
            const pinkTexture = createLightBeamTexture('rgba(255, 182, 193, 1)', 'rgba(255, 20, 147, 0.5)');
            
            // 3. Tạo ra các chùm sáng và lưu vào một mảng
            const lightBeams = [];
            const beamData = [
                // Các chùm sáng màu xanh lam (cyan)
                { texture: cyanTexture, radius: 80, speed: 0.25, yAmp: 20 },
                { texture: cyanTexture, radius: 120, speed: -0.2, yAmp: 15 },
                // Các chùm sáng màu xanh lá
                { texture: greenTexture, radius: 100, speed: 0.3, yAmp: -25 },
                { texture: greenTexture, radius: 150, speed: 0.15, yAmp: 10 },
                // Các chùm sáng màu hồng
                { texture: pinkTexture, radius: 90, speed: -0.28, yAmp: 22 },
                { texture: pinkTexture, radius: 130, speed: 0.22, yAmp: -18 },
            ];

            beamData.forEach(data => {
                const material = new THREE.SpriteMaterial({
                    map: data.texture,
                    blending: THREE.AdditiveBlending, // Hiệu ứng cộng sáng, làm cho nó rực rỡ hơn
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false, // Quan trọng để các vật thể trong suốt không che nhau sai cách
                });
                const sprite = new THREE.Sprite(material);
                
                const scale = 15 + Math.random() * 10; // Kích thước lớn, nổi bật hơn
                sprite.scale.set(scale, scale, scale);
                
                // Lưu trữ các thuộc tính di chuyển riêng cho mỗi chùm sáng
                sprite.userData = {
                    baseRadius: data.radius + (Math.random() - 0.5) * 20, // Bán kính quỹ đạo ngẫu nhiên
                    speed: data.speed * (0.8 + Math.random() * 0.4),      // Tốc độ ngẫu nhiên
                    yAmplitude: data.yAmp + (Math.random() - 0.5) * 10,   // Biên độ lên xuống ngẫu nhiên
                    yOffset: Math.random() * Math.PI * 2,
                    phaseOffset: Math.random() * Math.PI * 2,             // Vị trí bắt đầu ngẫu nhiên
                    pulseSpeed: 1 + Math.random() * 2                     // Tốc độ nhấp nháy ngẫu nhiên
                };
                
                lightBeams.push(sprite);
                scene.add(sprite); // Thêm chùm sáng vào cảnh
            });
            // =======================================================================
            // ===== KẾT THÚC PHẦN CODE MỚI =========================================
            // =======================================================================


            // Main animation loop
            const clock = new THREE.Clock();
            function animate() {
                galaxyAnimationId = requestAnimationFrame(animate);
                const deltaTime = clock.getDelta();
                const elapsedTime = clock.getElapsedTime();
                
                // Optimized firework management with brighter realistic effects
                fireworkTimer += deltaTime;
                if (scheduleIndex < fireworkSchedule.length && fireworkTimer >= fireworkSchedule[scheduleIndex].time) {
                    const schedule = fireworkSchedule[scheduleIndex];
                    for (let i = 0; i < schedule.count; i++) {
                        setTimeout(() => createFirework(schedule.type), i * 300);
                    }
                    scheduleIndex++;
                }
                
                // Reset schedule when complete
                if (scheduleIndex >= fireworkSchedule.length && fireworkTimer > 13) {
                    fireworkTimer = 0;
                    scheduleIndex = 0;
                }

                // Enhanced planet animations - SLOWER
                planet.rotation.y += 0.002; // Much slower
                planetGlow.rotation.y += 0.002; // Much slower
                ring.rotation.z += 0.0015; // Much slower
                particles.rotation.y += 0.001; // Much slower
                constellationGroup.rotation.y += 0.0005; // Much slower
                
                // Romantic twinkling effect for constellation
                constellationGroup.children.forEach((star, index) => {
                    const twinkle = 0.7 + 0.3 * Math.sin(elapsedTime * (2 + index * 0.3) + index * 2);
                    star.material.opacity = twinkle;
                });
                
                // Enhanced moon orbit with romantic lighting - SLOWER
                moon.position.x = Math.sin(elapsedTime * 0.4) * 35; // Much slower
                moon.position.z = Math.cos(elapsedTime * 0.4) * 35; // Much slower
                moon.position.y = Math.sin(elapsedTime * 0.2) * 8; // Much slower
                moon.rotation.y += 0.005; // Slower rotation
                
                // Enhanced romantic lighting effects
                centerSparkleLight.intensity = 3.5 + Math.sin(elapsedTime * 3) * 1.5; // Brighter
                planetGlow.material.opacity = 0.25 + Math.sin(elapsedTime * 1.5) * 0.1; // More visible
                
                // Animate romantic lights with more natural movement - SLOWER
                colorfulLights.forEach((light, index) => {
                    const angle = elapsedTime * 0.08 + (index * Math.PI * 2 / colorfulLights.length); // Much slower
                    light.position.x = Math.cos(angle) * (140 + Math.sin(elapsedTime * 0.5 + index) * 20);
                    light.position.z = Math.sin(angle) * (140 + Math.cos(elapsedTime * 0.5 + index) * 20);
                    light.position.y = Math.sin(elapsedTime * 0.3 + index) * 30; // Slower vertical movement
                    light.intensity = 1.8 + Math.sin(elapsedTime * 2 + index * 1.5) * 1; // Brighter
                });

                // Enhanced star twinkling
                starMaterial.opacity = 0.9 + 0.1 * Math.sin(elapsedTime * 0.3); // Brighter, slower twinkle

                // Image layer animations with MUCH slower movement and improved effects
                imageGroups.forEach(group => {
                    group.rotation.y += group.userData.rotationSpeed;
                    group.children.forEach(sprite => {
                        const twinkle = Math.sin(elapsedTime * sprite.userData.twinkleSpeed + sprite.userData.twinkleOffset);
                        sprite.material.opacity = sprite.userData.originalOpacity + twinkle * 0.15;
                    });
                });

                // =======================================================================
                // ===== BẮT ĐẦU PHẦN CODE MỚI: CẬP NHẬT VỊ TRÍ CÁC CHÙM SÁNG      =====
                // =======================================================================
                // 3. Trong mỗi khung hình, cập nhật vị trí của các chùm sáng
                lightBeams.forEach(beam => {
                    // Tính toán vị trí mới dựa trên thời gian đã trôi qua để tạo quỹ đạo
                    const t = elapsedTime * beam.userData.speed + beam.userData.phaseOffset;
                    beam.position.x = beam.userData.baseRadius * Math.cos(t);
                    beam.position.z = beam.userData.baseRadius * Math.sin(t);
                    beam.position.y = beam.userData.yAmplitude * Math.sin(t * 1.5 + beam.userData.yOffset); // Chuyển động lên xuống mượt hơn

                    // Thêm hiệu ứng nhấp nháy/thay đổi độ sáng
                    beam.material.opacity = 0.6 + 0.4 * Math.sin(elapsedTime * beam.userData.pulseSpeed);
                });
                // =======================================================================
                // ===== KẾT THÚC PHẦN CODE MỚI =========================================
                // =======================================================================
                
                // Update camera position
                camera.position.x = Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
                camera.position.y = Math.sin(cameraAngleX) * cameraDistance;
                camera.position.z = Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
                camera.lookAt(scene.position);
                
                // Update brighter realistic fireworks
                fireworks = fireworks.filter(firework => firework.update(deltaTime));
                
                // Performance management - limit fireworks
                if (fireworks.length > 8) { // Allow more fireworks
                    const oldestFirework = fireworks.shift();
                    if (oldestFirework.light) {
                        scene.remove(oldestFirework.light);
                    }
                    oldestFirework.particles.forEach(particle => {
                        scene.remove(particle.sprite);
                    });
                }
                
                renderer.render(scene, camera);
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>